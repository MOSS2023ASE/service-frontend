{"version":3,"file":"index.js","sources":["../src/tablemap.js","../src/util.js","../src/cellselection.js","../src/schema.js","../src/copypaste.js","../src/input.js","../src/fixtables.js","../src/commands.js","../src/tableview.js","../src/columnresizing.js","../src/index.js"],"sourcesContent":["// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nlet readFromCache, addToCache\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != \"undefined\") {\n  let cache = new WeakMap\n  readFromCache = key => cache.get(key)\n  addToCache = (key, value) => {\n    cache.set(key, value)\n    return value\n  }\n} else {\n  let cache = [], cacheSize = 10, cachePos = 0\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1]\n  }\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0\n    cache[cachePos++] = key\n    return cache[cachePos++] = value\n  }\n}\n\nexport class Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left; this.top = top; this.right = right; this.bottom = bottom\n  }\n}\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nexport class TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width\n    // :: number The table's height\n    this.height = height\n    // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n    this.map = map\n    // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n    this.problems = problems\n  }\n\n  // :: (number) → Rect\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i]\n      if (curPos != pos) continue\n      let left = i % this.width, top = (i / this.width) | 0\n      let right = left + 1, bottom = top + 1\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++\n      for (let j = 1; bottom < this.height && this.map[i + (this.width * j)] == curPos; j++) bottom++\n      return new Rect(left, top, right, bottom)\n    }\n    throw new RangeError(\"No cell with offset \" + pos + \" found\")\n  }\n\n  // :: (number) → number\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++)\n      if (this.map[i] == pos) return i % this.width\n    throw new RangeError(\"No cell with offset \" + pos + \" found\")\n  }\n\n  // :: (number, string, number) → ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    let {left, right, top, bottom} = this.findCell(pos)\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)]\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)]\n    }\n  }\n\n  // :: (number, number) → Rect\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    let {left: leftA, right: rightA, top: topA, bottom: bottomA} = this.findCell(a)\n    let {left: leftB, right: rightB, top: topB, bottom: bottomB} = this.findCell(b)\n    return new Rect(Math.min(leftA, leftB), Math.min(topA, topB),\n                    Math.max(rightA, rightB), Math.max(bottomA, bottomB))\n  }\n\n  // :: (Rect) → [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    let result = [], seen = {}\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col, pos = this.map[index]\n        if (seen[pos]) continue\n        seen[pos] = true\n        if ((col != rect.left || !col || this.map[index - 1] != pos) &&\n            (row != rect.top || !row || this.map[index - this.width] != pos))\n          result.push(pos)\n      }\n    }\n    return result\n  }\n\n  // :: (number, number, Node) → number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize\n      if (i == row) {\n        let index = col + row * this.width, rowEndIndex = (row + 1) * this.width\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index]\n      }\n      rowStart = rowEnd\n    }\n  }\n\n  // :: (Node) → TableMap\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table))\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name)\n  let width = findWidth(table), height = table.childCount\n  let map = [], mapPos = 0, problems = null, colWidths = []\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row)\n    pos++\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++\n      if (i == rowNode.childCount) break\n      let cellNode = rowNode.child(i), {colspan, rowspan, colwidth} = cellNode.attrs\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({type: \"overlong_rowspan\", pos, n: rowspan - h})\n          break\n        }\n        let start = mapPos + (h * width)\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos\n          else\n            (problems || (problems = [])).push({type: \"collision\", row, pos, n: colspan - w})\n          let colW = colwidth && colwidth[w]\n          if (colW) {\n            let widthIndex = ((start + w) % width) * 2, prev = colWidths[widthIndex]\n            if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {\n              colWidths[widthIndex] = colW\n              colWidths[widthIndex + 1] = 1\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++\n            }\n          }\n        }\n      }\n      mapPos += colspan\n      pos += cellNode.nodeSize\n    }\n    let expectedPos = (row + 1) * width, missing = 0\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++\n    if (missing) (problems || (problems = [])).push({type: \"missing\", row, n: missing})\n    pos++\n  }\n\n  let tableMap = new TableMap(width, height, map, problems), badWidths = false\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true\n  if (badWidths) findBadColWidths(tableMap, colWidths, table)\n\n  return tableMap\n}\n\nfunction findWidth(table) {\n  let width = -1, hasRowSpan = false\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row), rowWidth = 0\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      let prevRow = table.child(j)\n      for (let i = 0; i < prevRow.childCount; i++) {\n        let cell = prevRow.child(i)\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan\n      }\n    }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i)\n      rowWidth += cell.attrs.colspan\n      if (cell.attrs.rowspan > 1) hasRowSpan = true\n    }\n    if (width == -1)\n      width = rowWidth\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth)\n  }\n  return width\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = []\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i]\n    if (seen[pos]) continue\n    seen[pos] = true\n    let node = table.nodeAt(pos), updated = null\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width, colWidth = colWidths[col * 2]\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth\n    }\n    if (updated) map.problems.unshift({type: \"colwidth mismatch\", pos, colwidth: updated})\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice()\n  let result = []\n  for (let i = 0; i < attrs.colspan; i++) result.push(0)\n  return result\n}\n","// Various helper function for working with tables\n\nimport {PluginKey} from \"prosemirror-state\"\n\nimport {TableMap} from \"./tablemap\"\n\nexport const key = new PluginKey(\"selectingCells\")\n\nexport function cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1))\n  return null\n}\n\nexport function cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) { // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === 'header_cell') return $pos.node(d)\n  }\n  return null\n}\n\nexport function isInTable(state) {\n  let $head = state.selection.$head\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true\n  return false\n}\n\nexport function selectionCell(state) {\n  let sel = state.selection\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head)\n}\n\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    let role = after.type.spec.tableRole\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos)\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    let role = before.type.spec.tableRole\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize)\n  }\n}\n\nexport function pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && $pos.nodeAfter\n}\n\nexport function moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize)\n}\n\nexport function inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1)\n}\n\nexport function findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1))\n}\n\nexport function colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1))\n}\n\nexport function nextCell($pos, axis, dir) {\n  let start = $pos.start(-1), map = TableMap.get($pos.node(-1))\n  let moved = map.nextCell($pos.pos - start, axis, dir)\n  return moved == null ? null : $pos.node(0).resolve(start + moved)\n}\n\nexport function setAttr(attrs, name, value) {\n  let result = {}\n  for (let prop in attrs) result[prop] = attrs[prop]\n  result[name] = value\n  return result\n}\n\nexport function rmColSpan(attrs, pos, n=1) {\n  let result = setAttr(attrs, \"colspan\", attrs.colspan - n)\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice()\n    result.colwidth.splice(pos, n)\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null\n  }\n  return result\n}\n\nexport function addColSpan(attrs, pos, n=1) {\n  let result = setAttr(attrs, \"colspan\", attrs.colspan + n)\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice()\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0)\n  }\n  return result\n}\n","// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport {Selection, TextSelection, NodeSelection, SelectionRange} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\nimport {Fragment, Slice} from \"prosemirror-model\"\n\n\nimport {inSameTable, pointsAtCell, setAttr, rmColSpan} from \"./util\"\nimport {TableMap} from \"./tablemap\"\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nexport class CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1)\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    let cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - start)\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start)\n    let ranges = cells.map(pos => {\n      let cell = table.nodeAt(pos), from = pos + start + 1\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size))\n    })\n    super(ranges[0].$from, ranges[0].$to, ranges)\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos))\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos))\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1)\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell)\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell)\n      else\n        return new CellSelection($anchorCell, $headCell)\n    }\n    return TextSelection.between($anchorCell, $headCell)\n  }\n\n  // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1)\n    let rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start)\n    let seen = {}, rows = []\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = []\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        let pos = map.map[index]\n        if (!seen[pos]) {\n          seen[pos] = true\n          let cellRect = map.findCell(pos), cell = table.nodeAt(pos)\n          let extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs\n            if (extraLeft > 0) attrs = rmColSpan(attrs, 0, extraLeft)\n            if (extraRight > 0) attrs = rmColSpan(attrs, attrs.colspan - extraRight, extraRight)\n            if (cellRect.left < rect.left) cell = cell.type.createAndFill(attrs)\n            else cell = cell.type.create(attrs, cell.content)\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(cell.attrs, \"rowspan\", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top))\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs)\n            else cell = cell.type.create(attrs, cell.content)\n          }\n          rowContent.push(cell)\n        }\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)))\n    }\n\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1)\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n    }\n    let sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1)\n    if (sel) tr.setSelection(sel)\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0))\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1)\n    let cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start))\n    for (let i = 0; i < cells.length; i++)\n      f(table.nodeAt(cells[i]), start + cells[i])\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1)\n    if (Math.min(anchorTop, headTop) > 0) return false\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1)\n    let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.left])\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1])\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(start + map.map[headRect.left])\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1])\n    }\n    return new CellSelection($anchorCell, $headCell)\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1)\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start)\n    if (Math.min(anchorLeft, headLeft) > 0) return false\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan\n    return Math.max(anchorRight, headRight) == map.width\n  }\n\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1)\n    let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width])\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1])\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(start + map.map[headRect.top * map.width])\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1])\n    }\n    return new CellSelection($anchorCell, $headCell)\n  }\n\n  toJSON() {\n    return {type: \"cell\", anchor: this.$anchorCell.pos, head: this.$headCell.pos}\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → CellSelection\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell))\n  }\n\n  getBookmark() { return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos) }\n}\n\nCellSelection.prototype.visible = false\n\nSelection.jsonID(\"cell\", CellSelection)\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head)\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" &&\n        $headCell.parent.type.spec.tableRole == \"row\" &&\n        $anchorCell.index() < $anchorCell.parent.childCount &&\n        $headCell.index() < $headCell.parent.childCount &&\n        inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell)\n    else\n      return Selection.near($headCell, 1)\n  }\n}\n\nexport function drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null\n  let cells = []\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {class: \"selectedCell\"}))\n  })\n  return DecorationSet.create(state.doc, cells)\n}\n\nfunction isCellBoundarySelection({$from, $to}) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false // Cheap elimination\n  let afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole)\n}\n\nfunction isTextSelectionAcrossCells({$from, $to}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0\n}\n\nexport function normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection, doc = (tr || state).doc, normalize, role\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from)\n    } else if (role == \"row\") {\n      let $cell = doc.resolve(sel.from + 1)\n      normalize = CellSelection.rowSelection($cell, $cell)\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node), start = sel.from + 1\n      let lastCell = start + map.map[map.width * map.height - 1]\n      normalize = CellSelection.create(doc, start + 1, lastCell)\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from)\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize)\n  return tr\n}\n","// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  let widthAttr = dom.getAttribute(\"data-colwidth\")\n  let widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(s => Number(s)) : null\n  let colspan = Number(dom.getAttribute(\"colspan\") || 1)\n  let result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  }\n  for (let prop in extraAttrs) {\n    let getter = extraAttrs[prop].getFromDOM\n    let value = getter && getter(dom)\n    if (value != null) result[prop] = value\n  }\n  return result\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  let attrs = {}\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\")\n  for (let prop in extraAttrs) {\n    let setter = extraAttrs[prop].setDOMAttr\n    if (setter) setter(node.attrs[prop], attrs)\n  }\n  return attrs\n}\n\n// :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nexport function tableNodes(options) {\n  let extraAttrs = options.cellAttributes || {}\n  let cellAttrs = {\n    colspan: {default: 1},\n    rowspan: {default: 1},\n    colwidth: {default: null}\n  }\n  for (let prop in extraAttrs)\n    cellAttrs[prop] = {default: extraAttrs[prop].default}\n\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{tag: \"table\"}],\n      toDOM() { return [\"table\", [\"tbody\", 0]] }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{tag: \"tr\"}],\n      toDOM() { return [\"tr\", 0] }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{tag: \"td\", getAttrs: dom => getCellAttrs(dom, extraAttrs)}],\n      toDOM(node) { return [\"td\", setCellAttrs(node, extraAttrs), 0] }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{tag: \"th\", getAttrs: dom => getCellAttrs(dom, extraAttrs)}],\n      toDOM(node) { return [\"th\", setCellAttrs(node, extraAttrs), 0] }\n    }\n  }\n}\n\nexport function tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {}\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name], role = type.spec.tableRole\n      if (role) result[role] = type\n    }\n  }\n  return result\n}\n","// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Transform} from \"prosemirror-transform\"\n\nimport {setAttr, rmColSpan} from \"./util\"\nimport {TableMap} from \"./tablemap\"\nimport {CellSelection} from \"./cellselection\"\nimport {tableNodeTypes} from \"./schema\"\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nexport function pastedCells(slice) {\n  if (!slice.size) return null\n  let {content, openStart, openEnd} = slice\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == \"table\")) {\n    openStart--\n    openEnd--\n    content = content.firstChild.content\n  }\n  let first = content.firstChild, role = first.type.spec.tableRole\n  let schema = first.type.schema, rows = []\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content\n      let left = i ? 0 : Math.max(0, openStart - 1)\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1)\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content\n      rows.push(cells)\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content)\n  } else {\n    return null\n  }\n  return ensureRectangular(schema, rows)\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  let widths = []\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i]\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let {rowspan, colspan} = row.child(j).attrs\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan\n    }\n  }\n  let width = 0\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r])\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty)\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(), cells = []\n      for (let i = widths[r]; i < width; i++) cells.push(empty)\n      rows[r] = rows[r].append(Fragment.from(cells))\n    }\n  }\n  return {height: rows.length, width, rows}\n}\n\nexport function fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill()\n  let tr = new Transform(node).replace(0, node.content.size, slice)\n  return tr.doc\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nexport function clipCells({width, height, rows}, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [], newRows = []\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row], cells = []\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount)\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.create(rmColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content)\n        cells.push(cell)\n        col += cell.attrs.colspan\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan\n      }\n      newRows.push(Fragment.from(cells))\n    }\n    rows = newRows\n    width = newWidth\n  }\n\n  if (height != newHeight) {\n    let newRows = []\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [], source = rows[i % height]\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j)\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(setAttr(cell.attrs, \"rowspan\", newHeight - cell.attrs.rowspan), cell.content)\n        cells.push(cell)\n      }\n      newRows.push(Fragment.from(cells))\n    }\n    rows = newRows\n    height = newHeight\n  }\n\n  return {width, height, rows}\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row)\n      rowEnd += rowNode.nodeSize\n      let cells = [], add\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill())\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill())\n      for (let i = map.width; i < width; i++) cells.push(add)\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells)\n    }\n  }\n  if (height > map.height) {\n    let cells = []\n    for (let i = 0, start = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      let header = i >= map.width ? false :\n          table.nodeAt(map.map[start + i]).type == types.header_cell\n      cells.push(header\n                 ? (emptyHead || (emptyHead = types.header_cell.createAndFill()))\n                 : (empty || (empty = types.cell.createAndFill())))\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)), rows = []\n    for (let i = map.height; i < height; i++) rows.push(emptyRow)\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows)\n  }\n  return !!(empty || emptyHead)\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false\n  let found = false\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col, pos = map.map[index]\n    if (map.map[index - map.width] == pos) {\n      found = true\n      let cell = table.nodeAt(pos)\n      let {top: cellTop, left: cellLeft} = map.findCell(pos)\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, \"rowspan\", top - cellTop))\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n                cell.type.createAndFill(setAttr(cell.attrs, \"rowspan\", (cellTop + cell.attrs.rowspan) - top)))\n      col += cell.attrs.colspan - 1\n    }\n  }\n  return found\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false\n  let found = false\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left, pos = map.map[index]\n    if (map.map[index - 1] == pos) {\n      found = true\n      let cell = table.nodeAt(pos), cellLeft = map.colCount(pos)\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start)\n      tr.setNodeMarkup(updatePos, null, rmColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)))\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(rmColSpan(cell.attrs, 0, left - cellLeft)))\n      row += cell.attrs.rowspan - 1\n    }\n  }\n  return found\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nexport function insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table)\n  let {top, left} = rect\n  let right = left + cells.width, bottom = top + cells.height\n  let tr = state.tr, mapFrom = 0\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc\n    map = TableMap.get(table)\n    mapFrom = tr.mapping.maps.length\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp()\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp()\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp()\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp()\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp()\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table), to = map.positionAt(row, right, table)\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart),\n               new Slice(cells.rows[row - top], 0, 0))\n  }\n  recomp()\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n                                    tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))))\n  dispatch(tr)\n}\n","// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection} from \"prosemirror-state\"\nimport {keydownHandler} from \"prosemirror-keymap\"\n\nimport {key, nextCell, cellAround, inSameTable,\n        isInTable, selectionCell} from \"./util\"\nimport {CellSelection} from \"./cellselection\"\nimport {TableMap} from \"./tablemap\"\nimport {pastedCells, fitSlice, clipCells, insertCells} from \"./copypaste\"\nimport {tableNodeTypes} from \"./schema\"\n\nexport const handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1),\n\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n\n  \"Backspace\": deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  \"Delete\": deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n})\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView())\n  return true\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir))\n    }\n    if (axis != \"horiz\" && !sel.empty) return false\n    let end = atEndOfCell(view, axis, dir)\n    if (end == null) return false\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir))\n    } else {\n      let $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel\n      if ($next) newSel = Selection.near($next, 1)\n      else if (dir < 0) newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1)\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1)\n      return maybeSetSelection(state, dispatch, newSel)\n    }\n  }\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir)\n      if (end == null) return false\n      sel = new CellSelection(state.doc.resolve(end))\n    }\n    let $head = nextCell(sel.$headCell, axis, dir)\n    if (!$head) return false\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head))\n  }\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection\n  if (!(sel instanceof CellSelection)) return false\n  if (dispatch) {\n    let tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1),\n                   new Slice(baseContent, 0, 0))\n    })\n    if (tr.docChanged) dispatch(tr)\n  }\n  return true\n}\n\nexport function handleTripleClick(view, pos) {\n  let doc = view.state.doc, $cell = cellAround(doc.resolve(pos))\n  if (!$cell) return false\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)))\n  return true\n}\n\nexport function handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false\n  let cells = pastedCells(slice), sel = view.state.selection\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]}\n    let table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1)\n    let rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start)\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top)\n    insertCells(view.state, view.dispatch, start, rect, cells)\n    return true\n  } else if (cells) {\n    let $cell = selectionCell(view.state), start = $cell.start(-1)\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells)\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return\n\n  let startDOMCell = domInCell(view, startEvent.target), $anchor\n  if (startEvent.shiftKey && (view.state.selection instanceof CellSelection)) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent)\n    startEvent.preventDefault()\n  } else if (startEvent.shiftKey && startDOMCell &&\n             ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n             cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent)\n    startEvent.preventDefault()\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event)\n    let starting = key.getState(view.state) == null\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor\n      else return\n    }\n    let selection = new CellSelection($anchor, $head)\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection)\n      if (starting) tr.setMeta(key, $anchor.pos)\n      view.dispatch(tr)\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop)\n    view.root.removeEventListener(\"dragstart\", stop)\n    view.root.removeEventListener(\"mousemove\", move)\n    if (key.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(key, -1))\n  }\n\n  function move(event) {\n    let anchor = key.getState(view.state), $anchor\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor)\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent)\n      if (!$anchor) return stop()\n    }\n    if ($anchor) setCellSelection($anchor, event)\n  }\n  view.root.addEventListener(\"mouseup\", stop)\n  view.root.addEventListener(\"dragstart\", stop)\n  view.root.addEventListener(\"mousemove\", move)\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null\n  let {$head} = view.state.selection\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d)\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      let cellPos = $head.before(d)\n      let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n      return view.endOfTextblock(dirStr) ? cellPos : null\n    }\n  }\n  return null\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") return dom\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (!mousePos) return null\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null\n}\n","// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport {PluginKey} from \"prosemirror-state\"\nimport {TableMap} from \"./tablemap\"\nimport {setAttr, rmColSpan} from \"./util\"\nimport {tableNodeTypes} from \"./schema\"\nimport {key} from \"./util\"\n\nexport const fixTablesKey = new PluginKey(\"fix-tables\")\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount, curSize = cur.childCount\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i)\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1\n        offset += child.nodeSize\n        continue outer\n      }\n    }\n    f(child, offset)\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f)\n    else\n      child.nodesBetween(0, child.content.size, f, offset + 1)\n    offset += child.nodeSize\n  }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nexport function fixTables(state, oldState) {\n  let tr, check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr)\n  }\n  if (!oldState) state.doc.descendants(check)\n  else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check)\n  return tr\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table)\n  if (!map.problems) return tr\n  if (!tr) tr = state.tr\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  let mustAdd = []\n  for (let i = 0; i < map.height; i++) mustAdd.push(0)\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i]\n    if (prob.type == \"collision\") {\n      let cell = table.nodeAt(prob.pos)\n      for (let j = 0; j < cell.attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, rmColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n))\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n\n    } else if (prob.type == \"overlong_rowspan\") {\n      let cell = table.nodeAt(prob.pos)\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - prob.n))\n    } else if (prob.type == \"colwidth mismatch\") {\n      let cell = table.nodeAt(prob.pos)\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, \"colwidth\", prob.colwidth))\n    }\n  }\n  let first, last\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i\n    last = i\n  }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i)\n    let end = pos + row.nodeSize\n    let add = mustAdd[i]\n    if (add > 0) {\n      let tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole\n      }\n      let nodes = []\n      for (let j = 0; j < add; j++)\n        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill())\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1\n      tr.insert(tr.mapping.map(side), nodes)\n    }\n    pos = end\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true })\n}\n","// This file defines a number of table-related commands.\n\nimport {TextSelection} from \"prosemirror-state\"\nimport {Fragment} from \"prosemirror-model\"\n\nimport {TableMap, Rect} from \"./tablemap\"\nimport {CellSelection} from \"./cellselection\"\nimport {setAttr, addColSpan, rmColSpan, moveCellForward, isInTable, selectionCell} from \"./util\"\nimport {tableNodeTypes} from \"./schema\"\nimport {cellWrapping, cellAround} from './util'\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nfunction selectedRect(state) {\n  let sel = state.selection, $pos = selectionCell(state)\n  let table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table)\n  let rect\n  if (sel instanceof CellSelection)\n    rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart)\n  else\n    rect = map.findCell($pos.pos - tableStart)\n  rect.tableStart = tableStart\n  rect.map = map\n  rect.table = table\n  return rect\n}\n\nfunction columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false\n  return true\n}\n\n// Add a column at the given position in a table.\nexport function addColumn(tr, {map, tableStart, table}, col) {\n  let refColumn = col > 0 ? -1 : 0\n  if (columnIsHeader(map, table, col + refColumn))\n    refColumn = col == 0 || col == map.width ? null : 0\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index], cell = table.nodeAt(pos)\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null,\n                       addColSpan(cell.attrs, col - map.colCount(pos)))\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1\n    } else {\n      let type = refColumn == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type\n      let pos = map.positionAt(row, col, table)\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill())\n    }\n  }\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nexport function addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addColumn(state.tr, rect, rect.left))\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nexport function addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addColumn(state.tr, rect, rect.right))\n  }\n  return true\n}\n\nexport function removeColumn(tr, {map, table, tableStart}, col) {\n  let mapStart = tr.mapping.maps.length\n  for (let row = 0; row < map.height;) {\n    let index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos)\n    // If this is part of a col-spanning cell\n    if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null,\n                       rmColSpan(cell.attrs, col - map.colCount(pos)))\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos)\n      tr.delete(start, start + cell.nodeSize)\n    }\n    row += cell.attrs.rowspan\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nexport function deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state), tr = state.tr\n    if (rect.left == 0 && rect.right == rect.map.width) return false\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i)\n      if (i == rect.left) break\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc\n      rect.map = TableMap.get(rect.table)\n    }\n    dispatch(tr)\n  }\n  return true\n}\n\nfunction rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false\n  return true\n}\n\nexport function addRow(tr, {map, tableStart, table}, row) {\n  let rowPos = tableStart\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize\n  let cells = [], refRow = row > 0 ? -1 : 0\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      let pos = map.map[index], attrs = table.nodeAt(pos).attrs\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, \"rowspan\", attrs.rowspan + 1))\n      col += attrs.colspan - 1\n    } else {\n      let type = refRow == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type\n      cells.push(type.createAndFill())\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells))\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nexport function addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addRow(state.tr, rect, rect.top))\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nexport function addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addRow(state.tr, rect, rect.bottom))\n  }\n  return true\n}\n\nexport function removeRow(tr, {map, table, tableStart}, row) {\n  let rowPos = 0\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize\n  let nextRow = rowPos + table.child(row).nodeSize\n\n  let mapFrom = tr.mapping.maps.length\n  tr.delete(rowPos + tableStart, nextRow + tableStart)\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index]\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, \"rowspan\", attrs.rowspan - 1))\n      col += attrs.colspan - 1\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos)\n      let copy = cell.type.create(setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - 1), cell.content)\n      let newPos = map.positionAt(row + 1, col, table)\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy)\n      col += cell.attrs.colspan - 1\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nexport function deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state), tr = state.tr\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i)\n      if (i == rect.top) break\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc\n      rect.map = TableMap.get(rect.table)\n    }\n    dispatch(tr)\n  }\n  return true\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0\n}\n\nfunction cellsOverlapRectangle({width, height, map}, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1)\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] ||\n        rect.right < width && map[indexRight] == map[indexRight + 1]) return true\n    indexLeft += width; indexRight += width\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] ||\n        rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true\n    indexTop++; indexBottom++\n  }\n  return false\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nexport function mergeCells(state, dispatch) {\n  let sel = state.selection\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false\n  let rect = selectedRect(state), {map} = rect\n  if (cellsOverlapRectangle(map, rect)) return false\n  if (dispatch) {\n    let tr = state.tr, seen = {}, content = Fragment.empty, mergedPos, mergedCell\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos)\n        if (seen[cellPos]) continue\n        seen[cellPos] = true\n        if (mergedPos == null) {\n          mergedPos = cellPos\n          mergedCell = cell\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content)\n          let mapped = tr.mapping.map(cellPos + rect.tableStart)\n          tr.delete(mapped, mapped + cell.nodeSize)\n        }\n      }\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null,\n                     setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, (rect.right - rect.left) - mergedCell.attrs.colspan),\n                             \"rowspan\", rect.bottom - rect.top))\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content)\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)))\n    dispatch(tr)\n  }\n  return true\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nexport function splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node,\n  }) => {\n    return nodeTypes[node.type.spec.tableRole]\n  })(state, dispatch)\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nexport function splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection\n    let cellNode, cellPos\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from)\n      if (!cellNode) return false\n      cellPos = cellAround(sel.$from).pos\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false\n      cellNode = sel.$anchorCell.nodeAfter\n      cellPos = sel.$anchorCell.pos\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {return false}\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, \"rowspan\", 1)\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, \"colspan\", 1)\n      let rect = selectedRect(state), tr = state.tr\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(colwidth ? setAttr(baseAttrs, \"colwidth\", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs)\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table)\n        if (row == rect.top) pos += cellNode.nodeSize\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col}).createAndFill(attrs[i]))\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left}), attrs[0])\n      if (sel instanceof CellSelection)\n        tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),\n                                          lastCell && tr.doc.resolve(lastCell)))\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nexport function setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    let $cell = selectionCell(state)\n    if ($cell.nodeAfter.attrs[name] === value) return false\n    if (dispatch) {\n      let tr = state.tr\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value))\n        })\n      else\n        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value))\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema)\n      let rect = selectedRect(state), tr = state.tr\n      let cells = rect.map.cellsInRect(type == \"column\" ? new Rect(rect.left, 0, rect.right, rect.map.height) :\n                                       type == \"row\" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect)\n      let nodes = cells.map(pos => rect.table.nodeAt(pos))\n      for (let i = 0; i < cells.length; i++) // Remove headers, if any\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs)\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++) // No headers removed, add instead\n        tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs)\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1,\n  })\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i])\n    if (cell && cell.type !== types.header_cell) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nexport function toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false }\n\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type)\n\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema)\n      let rect = selectedRect(state), tr = state.tr\n\n      let isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types)\n      let isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types)\n\n      let isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled :\n                            type === \"row\"    ? isHeaderColumnEnabled : false\n\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0\n\n      let cellsRect = type == \"column\" ? new Rect(0, selectionStartsAt, 1, rect.map.height) :\n                      type == \"row\" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect\n\n      let newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell :\n                    type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell\n\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart\n        const cell = tr.doc.nodeAt(cellPos)\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs)\n        }\n      })\n\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nexport let toggleHeaderRow = toggleHeader(\"row\", { useDeprecatedLogic: true })\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nexport let toggleHeaderColumn = toggleHeader(\"column\", { useDeprecatedLogic: true })\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nexport let toggleHeaderCell = toggleHeader(\"cell\", { useDeprecatedLogic: true })\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore\n    if (before) return $cell.pos - before.nodeSize\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      let rowNode = $cell.node(-1).child(row)\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize\n      rowEnd -= rowNode.nodeSize\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize\n    let table = $cell.node(-1)\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      let rowNode = table.child(row)\n      if (rowNode.childCount) return rowStart + 1\n      rowStart += rowNode.nodeSize\n    }\n  }\n}\n\n// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nexport function goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    let cell = findNextCell(selectionCell(state), direction)\n    if (cell == null) return\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell)\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView())\n    }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\nexport function deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d)\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView())\n      return true\n    }\n  }\n  return false\n}\n","export class TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement(\"div\")\n    this.dom.className = \"tableWrapper\"\n    this.table = this.dom.appendChild(document.createElement(\"table\"))\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"))\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n    return true\n  }\n\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target))\n  }\n}\n\nexport function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0, fixedWidth = true\n  let nextDOM = colgroup.firstChild, row = node.firstChild\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let {colspan, colwidth} = row.child(i).attrs\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j]\n      let cssWidth = hasWidth ? hasWidth + \"px\" : \"\"\n      totalWidth += hasWidth || cellMinWidth\n      if (!hasWidth) fixedWidth = false\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth\n        nextDOM = nextDOM.nextSibling\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling\n    nextDOM.parentNode.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\"\n    table.style.minWidth = \"\"\n  } else {\n    table.style.width = \"\"\n    table.style.minWidth = totalWidth + \"px\"\n  }\n}\n","import {Plugin, PluginKey} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\nimport {cellAround, pointsAtCell, setAttr} from \"./util\"\nimport {TableMap} from \"./tablemap\"\nimport {TableView, updateColumns} from \"./tableview\"\nimport {tableNodeTypes} from \"./schema\"\n\nexport const key = new PluginKey(\"tableColumnResizing\")\n\nexport function columnResizing({ handleWidth = 5, cellMinWidth = 25, View = TableView, lastColumnResizable = true } = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] =\n          (node, view) => new View(node, cellMinWidth, view)\n        return new ResizeState(-1, false)\n      },\n      apply(tr, prev) {\n        return prev.apply(tr)\n      }\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state)\n        return pluginState.activeHandle > -1 ? {class: \"resize-cursor\"} : null\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) { handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) },\n        mouseleave(view) { handleMouseLeave(view) },\n        mousedown(view, event) { handleMouseDown(view, event, cellMinWidth) }\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state)\n        if (pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle)\n      },\n\n      nodeViews: {}\n    }\n  })\n  return plugin\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle\n    this.dragging = dragging\n  }\n\n  apply(tr) {\n    let state = this, action = tr.getMeta(key)\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, null)\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging)\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1)\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null\n      state = new ResizeState(handle, state.dragging)\n    }\n    return state\n  }\n}\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  let pluginState = key.getState(view.state)\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target), cell = -1\n    if (target) {\n      let {left, right} = target.getBoundingClientRect()\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\")\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\")\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell)\n        let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n        let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n\n        if (col == map.width - 1) {\n          return\n        }\n      }\n\n      updateHandle(view, cell)\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state)\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1)\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state)\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false\n\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle)\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs)\n  view.dispatch(view.state.tr.setMeta(key, {setDragging: {startX: event.clientX, startWidth: width}}))\n\n  function finish(event) {\n    window.removeEventListener(\"mouseup\", finish)\n    window.removeEventListener(\"mousemove\", move)\n    let pluginState = key.getState(view.state)\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth))\n      view.dispatch(view.state.tr.setMeta(key, {setDragging: null}))\n    }\n  }\n  function move(event) {\n    if (!event.which) return finish(event)\n    let pluginState = key.getState(view.state)\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth)\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth)\n  }\n\n  window.addEventListener(\"mouseup\", finish)\n  window.addEventListener(\"mousemove\", move)\n  event.preventDefault()\n  return true\n}\n\nfunction currentColWidth(view, cellPos, {colspan, colwidth}) {\n  let width = colwidth && colwidth[colwidth.length - 1]\n  if (width) return width\n  let dom = view.domAtPos(cellPos)\n  let node = dom.node.childNodes[dom.offset]\n  let domWidth = node.offsetWidth, parts = colspan\n  if (colwidth) for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n    domWidth -= colwidth[i]\n    parts--\n  }\n  return domWidth / parts\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList.contains(\"ProseMirror\") ? null : target.parentNode\n  return target\n}\n\nfunction edgeCell(view, event, side) {\n  let {pos} = view.posAtCoords({left: event.clientX, top: event.clientY})\n  let $cell = cellAround(view.state.doc.resolve(pos))\n  if (!$cell) return -1\n  if (side == \"right\") return $cell.pos\n  let map = TableMap.get($cell.node(-1)), start = $cell.start(-1)\n  let index = map.map.indexOf($cell.pos - start)\n  return index % map.width == 0 ? -1 : start + map.map[index - 1]\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX\n  return Math.max(cellMinWidth, dragging.startWidth + offset)\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, {setHandle: value}))\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell)\n  let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n  let tr = view.state.tr\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue\n    let pos = map.map[mapIndex], {attrs} = table.nodeAt(pos)\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos)\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue\n    let colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan)\n    colwidth[index] = width\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, \"colwidth\", colwidth))\n  }\n  if (tr.docChanged) view.dispatch(tr)\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell)\n  let table = $cell.node(-1), start = $cell.start(-1)\n  let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n  let dom = view.domAtPos($cell.start(-1)).node\n  while (dom.nodeName != \"TABLE\") dom = dom.parentNode\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width)\n}\n\nfunction zeroes(n) {\n  let result = []\n  for (let i = 0; i < n; i++) result.push(0)\n  return result\n}\n\nfunction handleDecorations(state, cell) {\n  let decorations = []\n  let $cell = state.doc.resolve(cell)\n  let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if ((col == map.width || map.map[index] != map.map[index + 1]) &&\n        (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      let cellPos = map.map[index]\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1\n      let dom = document.createElement(\"div\")\n      dom.className = \"column-resize-handle\"\n      decorations.push(Decoration.widget(pos, dom))\n    }\n  }\n  return DecorationSet.create(state.doc, decorations)\n}\n","// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport {Plugin} from \"prosemirror-state\"\n\nimport {handleTripleClick, handleKeyDown, handlePaste, handleMouseDown} from \"./input\"\nimport {key as tableEditingKey} from \"./util\"\nimport {drawCellSelection, normalizeSelection} from \"./cellselection\"\nimport {fixTables, fixTablesKey} from \"./fixtables\"\n\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nexport function tableEditing({ allowTableNodeSelection = false } = {}) {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() { return null },\n      apply(tr, cur) {\n        let set = tr.getMeta(tableEditingKey)\n        if (set != null) return set == -1 ? null : set\n        if (cur == null || !tr.docChanged) return cur\n        let {deleted, pos} = tr.mapping.mapResult(cur)\n        return deleted ? null : pos\n      }\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n\n      createSelectionBetween(view) {\n        if (tableEditingKey.getState(view.state) != null) return view.state.selection\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection)\n    }\n  })\n}\n\nexport {fixTables, handlePaste, fixTablesKey}\nexport {cellAround, isInTable, selectionCell, moveCellForward, inSameTable, findCell, colCount, nextCell} from \"./util\";\nexport {tableNodes} from \"./schema\"\nexport {CellSelection} from \"./cellselection\"\nexport {TableMap} from \"./tablemap\"\nexport {tableEditingKey};\nexport * from \"./commands\"\nexport {columnResizing, key as columnResizingPluginKey} from \"./columnresizing\"\nexport {updateColumns as updateColumnsOnResize} from \"./tableview\"\nexport {pastedCells as __pastedCells, insertCells as __insertCells, clipCells as __clipCells} from \"./copypaste\"\n"],"names":["let","cache","this","j","i","cell","PluginKey","const","pos","role","SelectionRange","super","TextSelection","attrs","Fragment","Slice","Selection","Decoration","DecorationSet","node","NodeSelection","r","Transform","newRows","row","cells","start","keydownHandler","rowNode","key","Plugin","handleMouseDown","tableEditingKey"],"mappings":"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"}